// Mock lucide-react icons
jest.mock('lucide-react', () => ({
  Search: () => <div data-testid="search-icon" />,
  Filter: () => <div data-testid="filter-icon" />,
  X: () => <div data-testid="x-icon" />,
  ChevronDown: () => <div data-testid="chevron-down-icon" />,
}))

describe('SearchFilterBar Component', () => {
  const mockData = [
    { id: '1', name: 'Alice Johnson', type: 'individual' },
    { id: '2', name: 'Bob Smith', type: 'organization' },
    { id: '3', name: 'Charlie Brown', type: 'individual' },
  ]

  const mockOnSearchChange = jest.fn()

  const defaultProps = {
    data: mockData,
    onSearchChange: mockOnSearchChange,
    searchOptions: {
      fields: ['name', 'type'],
      placeholder: 'Search items...',
      showAdvancedFilters: true,
    },
  }

  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('should render search input and basic controls', () => {
    render(<SearchFilterBar {...defaultProps} />)

    expect(screen.getByPlaceholderText('Search items...')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /filter/i })).toBeInTheDocument()
    expect(screen.getByTestId('search-icon')).toBeInTheDocument()
  })

  it('should handle search input changes', async () => {
    render(<SearchFilterBar {...defaultProps} />)

    const searchInput = screen.getByPlaceholderText('Search items...')
    fireEvent.change(searchInput, { target: { value: 'Alice' } })

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          query: 'Alice',
          filteredItems: [mockData[0]],
        })
      )
    })
  })

  it('should filter data based on search query', async () => {
    render(<SearchFilterBar {...defaultProps} />)

    const searchInput = screen.getByPlaceholderText('Search items...')
    fireEvent.change(searchInput, { target: { value: 'individual' } })

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          query: 'individual',
          filteredItems: [mockData[0], mockData[2]],
        })
      )
    })
  })

  it('should handle case-insensitive search', async () => {
    render(<SearchFilterBar {...defaultProps} />)

    const searchInput = screen.getByPlaceholderText('Search items...')
    fireEvent.change(searchInput, { target: { value: 'ALICE' } })

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          filteredItems: [mockData[0]],
        })
      )
    })
  })

  it('should show advanced filters when enabled', () => {
    render(<SearchFilterBar {...defaultProps} />)

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    expect(screen.getByText('Advanced Filters')).toBeInTheDocument()
  })

  it('should not show advanced filters when disabled', () => {
    render(
      <SearchFilterBar
        {...defaultProps}
        searchOptions={{
          ...defaultProps.searchOptions,
          showAdvancedFilters: false,
        }}
      />
    )

    const filterButton = screen.queryByRole('button', { name: /filter/i })
    expect(filterButton).not.toBeInTheDocument()
  })

  it('should handle filter configuration', () => {
    const filterConfig = {
      type: {
        label: 'Type',
        type: 'select' as const,
        options: [
          { key: 'type', label: 'Individual', value: 'individual' },
          { key: 'type', label: 'Organization', value: 'organization' },
        ],
      },
      status: {
        label: 'Status',
        type: 'multiselect' as const,
        options: [
          { key: 'status', label: 'Active', value: 'active' },
          { key: 'status', label: 'Inactive', value: 'inactive' },
        ],
      },
    }

    render(
      <SearchFilterBar
        {...defaultProps}
        filterConfig={filterConfig}
      />
    )

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    expect(screen.getByText('Type')).toBeInTheDocument()
    expect(screen.getByText('Status')).toBeInTheDocument()
  })

  it('should handle select filter changes', async () => {
    const filterConfig = {
      type: {
        label: 'Type',
        type: 'select' as const,
        options: [
          { key: 'type', label: 'Individual', value: 'individual' },
          { key: 'type', label: 'Organization', value: 'organization' },
        ],
      },
    }

    render(
      <SearchFilterBar
        {...defaultProps}
        filterConfig={filterConfig}
      />
    )

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    const selectElement = screen.getByRole('combobox')
    fireEvent.change(selectElement, { target: { value: 'individual' } })

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          filters: { type: 'individual' },
          filteredItems: [mockData[0], mockData[2]],
        })
      )
    })
  })

  it('should handle multiselect filter changes', async () => {
    const extendedMockData = [
      ...mockData,
      { id: '4', name: 'Diana Prince', type: 'individual', status: 'active' },
      { id: '5', name: 'Eve Wilson', type: 'individual', status: 'inactive' },
    ]

    const filterConfig = {
      status: {
        label: 'Status',
        type: 'multiselect' as const,
        options: [
          { key: 'status', label: 'Active', value: 'active' },
          { key: 'status', label: 'Inactive', value: 'inactive' },
        ],
      },
    }

    render(
      <SearchFilterBar
        {...defaultProps}
        data={extendedMockData}
        filterConfig={filterConfig}
      />
    )

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    // Find and check the Active checkbox
    const activeCheckbox = screen.getByRole('checkbox', { name: /active/i })
    fireEvent.click(activeCheckbox)

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          filters: { status: ['active'] },
          filteredItems: [extendedMockData[3]], // Only Diana Prince has status: active
        })
      )
    })
  })

  it('should handle date filter changes', async () => {
    const dateMockData = [
      { id: '1', name: 'Item 1', createdAt: '2024-01-15' },
      { id: '2', name: 'Item 2', createdAt: '2024-02-15' },
      { id: '3', name: 'Item 3', createdAt: '2024-03-15' },
    ]

    const filterConfig = {
      createdAt: {
        label: 'Created Date',
        type: 'date' as const,
      },
    }

    render(
      <SearchFilterBar
        {...defaultProps}
        data={dateMockData}
        filterConfig={filterConfig}
      />
    )

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    // Mock date input change
    const dateInput = screen.getByLabelText('Created Date Start')
    fireEvent.change(dateInput, { target: { value: '2024-02-01' } })

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          filters: { createdAt: { start: '2024-02-01' } },
        })
      )
    })
  })

  it('should handle sort options', () => {
    const sortOptions = {
      name: 'Name (A-Z)',
      createdAt: 'Date Created',
      type: 'Type',
    }

    render(
      <SearchFilterBar
        {...defaultProps}
        sortOptions={sortOptions}
      />
    )

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    expect(screen.getByText('Sort by')).toBeInTheDocument()
    expect(screen.getByText('Name (A-Z)')).toBeInTheDocument()
    expect(screen.getByText('Date Created')).toBeInTheDocument()
    expect(screen.getByText('Type')).toBeInTheDocument()
  })

  it('should handle sort changes', async () => {
    const sortOptions = {
      name: 'Name (A-Z)',
      createdAt: 'Date Created',
    }

    render(
      <SearchFilterBar
        {...defaultProps}
        sortOptions={sortOptions}
      />
    )

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    const sortSelect = screen.getByRole('combobox')
    fireEvent.change(sortSelect, { target: { value: 'name' } })

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          sortBy: 'name',
          sortOrder: 'asc',
        })
      )
    })
  })

  it('should clear all filters', async () => {
    const filterConfig = {
      type: {
        label: 'Type',
        type: 'select' as const,
        options: [
          { key: 'type', label: 'Individual', value: 'individual' },
        ],
      },
    }

    render(
      <SearchFilterBar
        {...defaultProps}
        filterConfig={filterConfig}
      />
    )

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    const selectElement = screen.getByRole('combobox')
    fireEvent.change(selectElement, { target: { value: 'individual' } })

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalled()
    })

    // Clear filters
    const clearButton = screen.getByRole('button', { name: /clear all/i })
    fireEvent.click(clearButton)

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          query: '',
          filters: {},
          sortBy: undefined,
          sortOrder: 'asc',
          filteredItems: mockData,
        })
      )
    })
  })

  it('should show filter count badge', () => {
    const filterConfig = {
      type: {
        label: 'Type',
        type: 'select' as const,
        options: [
          { key: 'type', label: 'Individual', value: 'individual' },
        ],
      },
    }

    render(
      <SearchFilterBar
        {...defaultProps}
        filterConfig={filterConfig}
      />
    )

    const filterButton = screen.getByRole('button', { name: /filter/i })
    fireEvent.click(filterButton)

    const selectElement = screen.getByRole('combobox')
    fireEvent.change(selectElement, { target: { value: 'individual' } })

    // Should show filter count
    expect(screen.getByText('1')).toBeInTheDocument()
  })

  it('should handle empty data array', () => {
    render(
      <SearchFilterBar
        {...defaultProps}
        data={[]}
      />
    )

    const searchInput = screen.getByPlaceholderText('Search items...')
    fireEvent.change(searchInput, { target: { value: 'test' } })

    expect(mockOnSearchChange).toHaveBeenCalledWith(
      expect.objectContaining({
        filteredItems: [],
      })
    )
  })

  it('should handle search with no matches', async () => {
    render(<SearchFilterBar {...defaultProps} />)

    const searchInput = screen.getByPlaceholderText('Search items...')
    fireEvent.change(searchInput, { target: { value: 'nonexistent' } })

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          filteredItems: [],
        })
      )
    })
  })

  it('should debounce search input', async () => {
    jest.useFakeTimers()

    render(<SearchFilterBar {...defaultProps} />)

    const searchInput = screen.getByPlaceholderText('Search items...')

    // Type multiple characters quickly
    fireEvent.change(searchInput, { target: { value: 'A' } })
    fireEvent.change(searchInput, { target: { value: 'Al' } })
    fireEvent.change(searchInput, { target: { value: 'Ali' } })
    fireEvent.change(searchInput, { target: { value: 'Alic' } })

    // Should only trigger search once after debounce
    jest.advanceTimersByTime(300)

    await waitFor(() => {
      expect(mockOnSearchChange).toHaveBeenCalledTimes(1)
      expect(mockOnSearchChange).toHaveBeenCalledWith(
        expect.objectContaining({
          query: 'Alic',
        })
      )
    })

    jest.useRealTimers()
  })

  it('should handle custom className prop', () => {
    render(
      <SearchFilterBar
        {...defaultProps}
        className="custom-class"
      />
    )

    const container = screen.getByTestId('search-filter-bar-container')
    expect(container).toHaveClass('custom-class')
  })
})
// Mock useSearch hook
jest.mock('../../src/hooks/use-search', () => ({
  useSearch: jest.fn(() => ({
    searchTerm: '',
    filters: {},
    sortBy: '',
    sortOrder: 'asc',
    result: {
      items: [],
      total: 0,
      filtered: 0,
      searchTerm: '',
      filters: {},
      highlightedItems: [],
      query: '',
      filteredItems: []
    },
    updateSearchTerm: jest.fn(),
    updateFilter: jest.fn(),
    clearFilter: jest.fn(),
    clearAllFilters: jest.fn(),
    updateSort: jest.fn(),
    getFilterOptions: jest.fn(() => [])
  }))
}))


// Mock useSearch hook
jest.mock('../../src/hooks/use-search', () => ({
  useSearch: jest.fn((data = [], options = {}) => {
    const mockData = [
      { id: '1', name: 'Alice Johnson', type: 'individual' },
      { id: '2', name: 'Bob Smith', type: 'organization' },
      { id: '3', name: 'Charlie Brown', type: 'individual' },
    ]
    const currentData = data.length > 0 ? data : mockData
    let searchTerm = ''
    let filteredItems = [...currentData]
    
    const updateSearchTerm = jest.fn((term) => {
      searchTerm = term
      if (term && term.length >= (options.minLength || 2)) {
        const searchLower = term.toLowerCase()
        const fields = options.fields || ['name', 'type']
        filteredItems = currentData.filter((item) => {
          return fields.some((field) => {
            const value = item[field]
            if (value === null || value === undefined) return false
            return String(value).toLowerCase().includes(searchLower)
          })
        })
      } else {
        filteredItems = [...currentData]
      }
    })
    
    return {
      searchTerm,
      filters: {},
      sortBy: '',
      sortOrder: 'asc',
      result: {
        items: filteredItems,
        total: currentData.length,
        filtered: filteredItems.length,
        searchTerm,
        filters: {},
        highlightedItems: [],
        query: searchTerm,
        filteredItems: filteredItems
      },
      updateSearchTerm,
      updateFilter: jest.fn(),
      clearFilter: jest.fn(),
      clearAllFilters: jest.fn(() => {
        searchTerm = ''
        filteredItems = [...currentData]
      }),
      updateSort: jest.fn(),
      getFilterOptions: jest.fn(() => [])
    }
  })
}))
// Mock useSearch hook
jest.mock('../../src/hooks/use-search', () => ({
  useSearch: jest.fn((data = [], options = {}) => {
    const mockData = [
      { id: '1', name: 'Alice Johnson', type: 'individual' },
      { id: '2', name: 'Bob Smith', type: 'organization' },
      { id: '3', name: 'Charlie Brown', type: 'individual' },
    ]
    const currentData = data.length > 0 ? data : mockData
    let searchTerm = ''
    let filteredItems = [...currentData]
    
    const updateSearchTerm = jest.fn((term) => {
      searchTerm = term
      if (term && term.length >= (options.minLength || 2)) {
        const searchLower = term.toLowerCase()
        const fields = options.fields || ['name', 'type']
        filteredItems = currentData.filter((item) => {
          return fields.some((field) => {
            const value = item[field]
            if (value === null || value === undefined) return false
            return String(value).toLowerCase().includes(searchLower)
          })
        })
      } else {
        filteredItems = [...currentData]
      }
    })
    
    return {
      searchTerm,
      filters: {},
      sortBy: '',
      sortOrder: 'asc',
      result: {
        items: filteredItems,
        total: currentData.length,
        filtered: filteredItems.length,
        searchTerm,
        filters: {},
        highlightedItems: [],
        query: searchTerm,
        filteredItems: filteredItems
      },
      updateSearchTerm,
      updateFilter: jest.fn(),
      clearFilter: jest.fn(),
      clearAllFilters: jest.fn(() => {
        searchTerm = ''
        filteredItems = [...currentData]
      }),
      updateSort: jest.fn(),
      getFilterOptions: jest.fn(() => [])
    }
  })
}))
